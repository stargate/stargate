# Stargate schema-first CQL directives.
#
# They allow you to customize certain aspects of the GraphQL => CQL mapping.
#
# They will be added automatically to any schema uploaded to Stargate (you don't need to copy
# them).


"The type of schema element a GraphQL object maps to"
enum EntityTarget { TABLE UDT }


"Customizes the mapping of a GraphQL object to a CQL table or UDT"
directive @cql_entity(

    "A custom table or UDT name (otherwise it uses the same name as the object)"
    name: String

    "Whether the object maps to a CQL table (the default) or UDT"
    target: EntityTarget

) on OBJECT

"""
Annotates a GraphQL object to trigger the generation of a matching input type.
The generated type will have the same fields (names and types), and can be referenced in mutations
that target the corresponding CQL table or UDT.
"""
directive @cql_input(

    """
    The name of the generated type. If not specified, it will be generated by appending 'Input' to
    the name of the original object
    """
    name: String

) on OBJECT

"The sorting order for clustering columns"
enum ClusteringOrder { ASC DESC }


"Customizes the mapping of a GraphQL field to a CQL column (or UDT field)"
directive @cql_column(

    "A custom column name (otherwise it uses the same name as the field)"
    name: String

    "Whether the column forms part of the partition key"
    partitionKey: Boolean

    "Whether the column is a clustering column, and if so in which order"
    clusteringOrder: ClusteringOrder

    """
    The CQL type to map to (e.g. `frozen<list<varchar>>`).
    Most of the time you don't need this, the CQL type will be inferred from the GraphQL type. It
    is only needed for fine control over the "frozen-ness" of columns, or if you want to map a
    GraphQL list to a CQL set (instead of a list).
    """
    typeHint: String

) on FIELD_DEFINITION


"Which part of a collection field will be indexed."
enum IndexTarget {

    """
    Indexes the values of a list field.
    This is only allowed if the CQL type is not frozen.
    """
    VALUES

    """
    Indexes the full collection for a list, set or map column.
    This is only allowed if the CQL type is frozen.
    """
    FULL
}


"""
Requests the creation of a CQL index for a GraphQL object field.

This is only allowed for objects that map to CQL tables, and only for non-partition-key fields (in
other words, fields that have neither `@cql_column.partitionKey` nor `@cql_column.clusteringOrder`
set).
"""
directive @cql_index (

    """
    A custom name for the index. If not specified, one will be generated.
    """
    name: String

    """
    If the index is custom, the name of the index class to use. If not specified, this will be a
    regular secondary index.
    """
    class: String

    """
    (Only used with list fields) Which part of the field to index. If not specified, this will
    default to `VALUES`.
    """
    target: IndexTarget

    """
    Any custom options to pass to the index, in the format: `'option1': 'value1', 'option2':
    'value2'...`
    """
    options: String

) on FIELD_DEFINITION


"""
Provides additional options to the CQL SELECT generated for a query.
This is only required if you pass arguments to the directive. Otherwise, GraphQL queries are always
mapped to SELECT implicitly.
"""
directive @cql_select(
    """
    How many results to return overall.
    """
    limit: Int

    """
    How many results to return at a time.
    If there are more, paging can be implemented by:

    * wrapping the return type into an object annotated with @cql_payload, that defines a field
      `pagingState: String`;
    * adding a `String` parameter annotated with `@cql_pageState` to the query.

    Then the page state returned by each query can be reinjected into the next query to get the
    next page.
    """
    pageSize: Int = 100
) on FIELD_DEFINITION

"""
Annotates a query parameter to indicate that it will receive the paging state. That parameter must
have type `String`.
"""
directive @cql_pagingState on ARGUMENT_DEFINITION

"""
Indicates that a mutation should be mapped to a CQL INSERT query.
Note that this is not required if the mutation name starts with `insert` or `create`.
"""
directive @cql_insert(
    """
    What to do if the entity already exists.

    * If `false`, the insert will overwrite any data that was already present.
    * If `true`, it won't, and the mutation will return the existing entity. In this case, it is
      strongly recommended to wrap the response in a payload object that also defines an `applied`
      field, for example: `type InsertUserResponse @cql_payload { applied: Boolean!, user: User! }`

    Note that setting this flag to `true` might increase the latency of the operation. It should
    not be used casually.

    By convention, this flag will be set automatically if the mutation name ends with
    `IfNotExists`.
    """
    ifNotExists: Boolean = false
) on FIELD_DEFINITION

"""
Indicates that a mutation should be mapped to a CQL UPDATE query.
Note that this is not required if the mutation name starts with `update`.
"""
directive @cql_update on FIELD_DEFINITION

"""
Indicates that a mutation should be mapped to a CQL DELETE query.
Note that this is not required if the mutation name starts with `delete` or `remove`.
"""
directive @cql_delete(
    """
    The name of the type to delete. This is only needed if the mutation takes individual key fields
    as arguments (as opposed to an instance of the type).
    This must be a type that maps to a table.
    """
    targetEntity: String

    """
    Whether to check if the entity exists before deleting.

    Delete mutations return the outcome of the deletion, either directly if the mutation returns
    `Boolean`, or via the `applied` field if the mutation returns a response payload object.

    * If `ifExists` is `false`, the mutation will always return `true`, whether it actually deleted
      something or not.
    * If `ifExists` is `true`, the mutation will return `true` if it deleted something, and `false`
      otherwise.

    Note that setting this flag to `true` might increase the latency of the operation. It should
    not be used casually.

    By convention, this flag will be set automatically if the mutation name ends with `IfExists`.
    """
    ifExists: Boolean = false
) on FIELD_DEFINITION

"""
A predicate used in `@cql_where` and `@cql_if` to define a condition.
"""
enum Predicate {
    EQ
    IN
    LT
    GT
    LTE
    GTE
    CONTAINS
}

"""
Annotates a parameter to customize the WHERE condition that is generated from it.
"""
directive @cql_where (

    """
    The name of the field that the condition applies to (if absent, it will be the name of the
    argument).
    """
    field: String

    """
    The predicate to use for the condition.
    """
    predicate: Predicate = EQ
) on ARGUMENT_DEFINITION

"""
Annotates a parameter to customize the DELETE condition that is generated from it.
"""
directive @cql_if (

    """
    The name of the field that the condition applies to (if absent, it will be the name of the
    argument).
    """
    field: String

    """
    The predicate to use for the condition.
    """
    predicate: Predicate = EQ
) on ARGUMENT_DEFINITION

"""
Indicates that a type represents a "payload" object that will be used as the argument or return
type of a GraphQL operation. Such objects  are NOT mapped to a CQL table.
"""
directive @cql_payload on OBJECT | INPUT_OBJECT
